name: PR â€¢ Situational Report Footer

on:
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review]

permissions:
  pull-requests: write
  contents: read

jobs:
  sr-footer:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Post/Update SR footer
        uses: actions/github-script@v7
        env:
          # Set this in your repo secrets to your deployed portal base (no trailing slash),
          # e.g., https://your-app.vercel.app
          KAIZEN_PORTAL_BASE: ${{ secrets.KAIZEN_PORTAL_BASE }}
          # Optional: override kind or limit if you create other SR types
          SR_KIND: situational_report
          SR_LIMIT: "1"
        with:
          script: |
            const portal = process.env.KAIZEN_PORTAL_BASE;
            const kind   = process.env.SR_KIND || "situational_report";
            const limit  = process.env.SR_LIMIT || "1";

            if (!portal) {
              core.setFailed("KAIZEN_PORTAL_BASE secret not set (e.g., https://your-app.vercel.app)");
              process.exit(1);
            }

            const listUrl = `${portal}/api/sr?kind=${encodeURIComponent(kind)}&limit=${encodeURIComponent(limit)}`;
            core.info(`Fetching SR list: ${listUrl}`);

            let items = [];
            try {
              const r = await fetch(listUrl, { headers: { 'Accept': 'application/json' }});
              if (!r.ok) throw new Error(`SR list fetch failed: ${r.status} ${await r.text()}`);
              const data = await r.json();
              items = Array.isArray(data) ? data : (data.items || []);
            } catch (e) {
              core.warning(`Failed to fetch SRs: ${e.message}`);
            }

            // Build markdown
            let md;
            if (!items.length) {
              md = [
                "<!-- SR_FOOTER_MARKER -->",
                "### ðŸ§­ Situational Report",
                "",
                "> No situational reports found yet. Once JADE emits an SR, this footer will summarize the latest verdict here.",
                "",
                `_Source: ${portal}/api/sr?_=` + Date.now() // cache-buster for reviewers
              ].join("\n");
            } else {
              const sr = items[0];
              const id = sr.event_id || "unknown";
              const verdict = (sr.details?.verdict || "Unknown").toUpperCase();
              const subject = sr.details?.subject || "Situational Report";
              const cycle = sr.details?.cycle || "â€”";
              const gi = typeof sr.gi === "number" ? sr.gi.toFixed(3) : "â€”";
              const t = sr.timestamp ? new Date(sr.timestamp).toISOString() : "â€”";
              const link = `${portal}/consensus/sr/${encodeURIComponent(id)}`;

              // simple color badge by verdict
              const color =
                verdict.includes("ADOPT") ? "brightgreen" :
                verdict.includes("SHADOW") ? "orange" :
                verdict.includes("DEFER") ? "red" : "blue";

              md = [
                "<!-- SR_FOOTER_MARKER -->",
                "### ðŸ§­ Situational Report",
                "",
                `**${subject}**  Â·  Cycle **${cycle}**  Â·  GI **${gi}**  Â·  ${t}`,
                "",
                `![verdict](https://img.shields.io/badge/Verdict-${encodeURIComponent(verdict)}-${color})`,
                "",
                `**Read full SR:** ${link}`,
                "",
                "<sub>Auto-posted by Kaizen OS SR Footer Bot Â· Source: `/api/sr`</sub>"
              ].join("\n");
            }

            const { context, github } = require('@actions/github');

            // Idempotent update: find existing comment by marker
            const marker = "<!-- SR_FOOTER_MARKER -->";
            const { owner, repo } = context.repo;
            const issue_number = context.payload.pull_request.number;

            const comments = await github.rest.issues.listComments({
              owner, repo, issue_number, per_page: 100
            });

            const existing = comments.data.find(c => (c.user?.type === "Bot" || c.user?.login.endsWith("[bot]")) && (c.body || "").includes(marker));

            if (existing) {
              await github.rest.issues.updateComment({
                owner, repo,
                comment_id: existing.id,
                body: md
              });
              core.info(`Updated SR footer on comment ${existing.id}`);
            } else {
              await github.rest.issues.createComment({
                owner, repo, issue_number, body: md
              });
              core.info("Posted new SR footer comment");
            }
